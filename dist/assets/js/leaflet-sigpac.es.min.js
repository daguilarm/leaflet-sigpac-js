var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _i_instances, e_fn, t_fn, _r_instances, i_fn, r_fn, a_fn, _a_instances, o_fn, s_fn, n_fn, c_fn, _n_instances, l_fn, _c_instances, p_fn, h_fn, _h_instances, d_fn, g_fn, _g_instances, u_fn, f_fn, m_fn, y_fn, w_fn, b_fn, v_fn;
class e {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
  }
  on(e2, t2) {
    this.events.has(e2) || this.events.set(e2, /* @__PURE__ */ new Set()), this.events.get(e2).add(t2);
  }
  emit(e2, t2) {
    this.events.has(e2) && this.events.get(e2).forEach((e3) => e3(t2));
  }
  off(e2, t2) {
    if (this.events.has(e2)) {
      const i2 = this.events.get(e2);
      i2.delete(t2), 0 === i2.size && this.events.delete(e2);
    }
  }
  offAll() {
    this.events.clear();
  }
}
const t = ["debug", "info", "warn", "error"];
class i {
  constructor(e2 = false) {
    __privateAdd(this, _i_instances);
    this.currentLevel = e2 ? "debug" : "warn";
  }
  setLogLevel(e2) {
    t.includes(e2) && (this.currentLevel = e2);
  }
  debug(e2, t2 = null) {
    __privateMethod(this, _i_instances, e_fn).call(this, "debug", e2, t2);
  }
  info(e2, t2 = null) {
    __privateMethod(this, _i_instances, e_fn).call(this, "info", e2, t2);
  }
  warn(e2, t2 = null) {
    __privateMethod(this, _i_instances, e_fn).call(this, "warn", e2, t2);
  }
  error(e2, t2 = null) {
    __privateMethod(this, _i_instances, e_fn).call(this, "error", e2, t2);
  }
}
_i_instances = new WeakSet();
e_fn = function(e2, t2, i2) {
  if (__privateMethod(this, _i_instances, t_fn).call(this, e2)) {
    const r2 = console[e2] || console.log, a2 = `[SIGPAC-${e2.toUpperCase()}]`;
    i2 ? r2(`${a2} ${t2}`, i2) : r2(`${a2} ${t2}`);
  }
};
t_fn = function(e2) {
  return t.indexOf(e2) >= t.indexOf(this.currentLevel);
};
class r {
  constructor(e2) {
    __privateAdd(this, _r_instances);
    this.cache = /* @__PURE__ */ new Map(), this.config = e2, this.accessOrder = [];
  }
  get(e2) {
    const t2 = __privateMethod(this, _r_instances, i_fn).call(this, e2), i2 = this.cache.get(t2);
    if (i2) {
      if (Date.now() - i2.timestamp < this.config.ttl) return __privateMethod(this, _r_instances, r_fn).call(this, t2), i2.data;
      this.cache.delete(t2), __privateMethod(this, _r_instances, a_fn).call(this, t2);
    }
  }
  set(e2, t2) {
    if (!this.config.enabled) return;
    const i2 = __privateMethod(this, _r_instances, i_fn).call(this, e2);
    if (this.accessOrder.length >= this.config.maxSize) {
      const e3 = this.accessOrder.shift();
      this.cache.delete(e3);
    }
    this.cache.set(i2, { data: t2, timestamp: Date.now() }), __privateMethod(this, _r_instances, r_fn).call(this, i2);
  }
  clear() {
    this.cache.clear(), this.accessOrder = [];
  }
}
_r_instances = new WeakSet();
i_fn = function(e2) {
  return `${e2.lat.toFixed(this.config.precision)}_${e2.lng.toFixed(this.config.precision)}`;
};
r_fn = function(e2) {
  __privateMethod(this, _r_instances, a_fn).call(this, e2), this.accessOrder.push(e2);
};
a_fn = function(e2) {
  const t2 = this.accessOrder.indexOf(e2);
  -1 !== t2 && this.accessOrder.splice(t2, 1);
};
class a {
  constructor(e2, t2) {
    __privateAdd(this, _a_instances);
    this.config = e2, this.logger = t2, this.cache = new r(this.config.cacheConfig), this.logger.info("Cache initialized: " + (this.config.cacheConfig.enabled ? `Enabled (TTL: ${this.config.cacheConfig.ttl}ms, Size: ${this.config.cacheConfig.maxSize})` : "Disabled"));
  }
  async fetchParcelaByCoordinates(e2) {
    if (this.config.cacheConfig.enabled) {
      const t2 = this.cache.get(e2);
      if (t2) return this.logger.debug("Using cached SIGPAC data"), t2;
    }
    try {
      const t2 = __privateMethod(this, _a_instances, o_fn).call(this, e2);
      this.logger.info("Fetching SIGPAC data", { url: t2 });
      const i2 = await fetch(t2, { headers: { Accept: "application/json" }, signal: AbortSignal.timeout(1e4) });
      if (!i2.ok) {
        const e3 = await i2.text();
        throw new Error(`HTTP ${i2.status}: ${e3.substring(0, 100)}`);
      }
      const r2 = await i2.json(), a2 = __privateMethod(this, _a_instances, s_fn).call(this, r2);
      return a2 && this.config.cacheConfig.enabled && this.cache.set(e2, a2), a2;
    } catch (e3) {
      throw this.logger.error("SIGPAC fetch error", e3), e3;
    }
  }
}
_a_instances = new WeakSet();
o_fn = function(e2) {
  const t2 = e2.lat.toFixed(6), i2 = e2.lng.toFixed(6);
  return `${this.config.sigpacCoordinateQueryUrl}4326/${i2}/${t2}.json`;
};
s_fn = function(e2) {
  return Array.isArray(e2) && e2.length > 0 ? __privateMethod(this, _a_instances, n_fn).call(this, e2[0]) : null;
};
n_fn = function(e2) {
  try {
    return this.logger.debug("Parsing SIGPAC data", e2), { provincia: e2.provincia || "N/A", municipio: e2.municipio || "N/A", zona: e2.zona || 0, poligono: e2.poligono, parcela: e2.parcela, recinto: e2.recinto, uso: e2.uso_sigpac || "N/A", superficie: __privateMethod(this, _a_instances, c_fn).call(this, e2.dn_surface), cultivo: "N/A", pendiente: e2.pendiente_media || "N/A", regadio: e2.coef_regadio || "N/A", incidencias: e2.incidencias || "N/A", admisibilidad: e2.admisibilidad || "N/A", wkt: e2.wkt, srid: e2.srid };
  } catch (e3) {
    return this.logger.error("SIGPAC parse error", e3), null;
  }
};
c_fn = function(e2) {
  if (!e2) return "N/A";
  const t2 = e2 / 1e4;
  return isNaN(t2) ? "N/A" : t2.toFixed(2);
};
const o = { ...{ debug: false, livewire: false, livewireEvent: "sigpacFeatureSelected", sigpacWmsUrl: "https://sigpac-hubcloud.es/wms", sigpacLayerName: "recinto", sigpacCoordinateQueryUrl: "https://sigpac-hubcloud.es/servicioconsultassigpac/query/recinfobypoint/", minZoomFeature: 12, defaultMapOptions: { center: [40.416775, -3.70379], zoom: 13, maxZoom: 19, minZoom: 5, tileUrl: "https://tms-pnoa-ma.idee.es/1.0.0/pnoa-ma/{z}/{x}/{-y}.jpeg", attribution: '<a href="https://www.scne.es/">CC BY 4.0 scne.es</a>' }, cacheConfig: { enabled: true, ttl: 3e5, maxSize: 100, precision: 4 }, externalLibs: { terraformer: { url: "https://unpkg.com/terraformer@1.0.9/terraformer.js", integrity: "sha384-7e0rV8XjC1y0KZxlB+4O7w8n2gxV6Z7u6z5p5z5z5z5z5z5z5z5z5z5z5z5z5z5" }, terraformerWkt: { url: "https://unpkg.com/terraformer-wkt-parser@1.2.1/terraformer-wkt-parser.min.js", integrity: "sha384-7e0rV8XjC1y0KZxlB+4O7w8n2gxV6Z7u6z5p5z5z5z5z5z5z5z5z5z5z5z5z5z5" } }, markerLoadingIcon: L.icon({ iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-gold.png", iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34] }), markerErrorIcon: L.icon({ iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png", iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34] }) }, hideLeafletAttribution: false, interactionMode: "popup", initialFeatures: [], popupFields: null, markerIconUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png", clickEnabled: true };
class s {
  constructor(e2 = {}) {
    this.userConfig = e2;
  }
  getConfig() {
    const e2 = { ...o, ...this.userConfig }, t2 = {};
    return ["minZoom", "maxZoom", "center", "zoom", "tileUrl", "attribution"].forEach((i2) => {
      void 0 !== this.userConfig[i2] && (t2[i2] = this.userConfig[i2], delete e2[i2]);
    }), e2.defaultMapOptions = { ...o.defaultMapOptions, ...t2, ...this.userConfig.defaultMapOptions || {} }, e2;
  }
}
class n {
  constructor(e2, t2) {
    __privateAdd(this, _n_instances);
    this.config = e2, this.map = t2, __privateMethod(this, _n_instances, l_fn).call(this);
  }
  initBaseLayer(e2) {
    this.baseLayer = L.tileLayer(e2.tileUrl, { maxZoom: e2.maxZoom, minZoom: e2.minZoom }).addTo(this.map);
  }
  initSigpacLayer() {
    this.sigpacLayer = L.tileLayer.wms(this.config.sigpacWmsUrl, { layers: this.config.sigpacLayerName, format: "image/png", transparent: true, version: "1.3.0", maxZoom: this.config.defaultMapOptions.maxZoom, minZoom: this.config.minZoomFeature, tileSize: 512, opacity: 0.7 });
  }
  setupLayerControl() {
    this.baseLayer && L.control.layers({ "Base Layer": this.baseLayer }, { SIGPAC: this.sigpacLayer }, { collapsed: false }).addTo(this.map);
  }
}
_n_instances = new WeakSet();
l_fn = function() {
  const e2 = this.map.attributionControl;
  e2 && (this.config.hideLeafletAttribution && e2.setPrefix(""), this.config.defaultMapOptions.attribution && e2.addAttribution(this.config.defaultMapOptions.attribution));
};
class c {
  constructor(e2, t2, i2) {
    __privateAdd(this, _c_instances);
    this.map = e2, this.config = t2, this.geometryManager = i2, this.popupPool = [];
  }
  showLoadingPopup(e2) {
    return __privateMethod(this, _c_instances, h_fn).call(this, e2, '<div class="sigpac-loading">Loading SIGPAC data...</div>');
  }
  showErrorPopup(e2, t2) {
    return this.map.closePopup(), __privateMethod(this, _c_instances, h_fn).call(this, e2, `<div class="sigpac-error">${t2}</div>`);
  }
  showParcelaInfo(e2, t2) {
    this.geometryManager.clearLayers();
    const i2 = this.buildPopupContent(e2);
    switch (this.config.interactionMode) {
      case "marker":
        __privateMethod(this, _c_instances, p_fn).call(this, e2, t2, i2);
        break;
      case "popup":
        __privateMethod(this, _c_instances, h_fn).call(this, t2, i2);
    }
  }
  buildPopupContent(e2) {
    return `
      <div class="sigpac-popup">
        <div class="sigpac-popup-title">SIGPAC Parcel</div>
        <div class="sigpac-popup-content">${this.getFieldsConfig(e2).map((e3) => {
      return `
      <div class="sigpac-popup-row">
        <span class="sigpac-popup-label">${e3.label}</span>
        <span class="sigpac-popup-value">
          ${t2 = e3.value, t2 ?? "N/A"}${e3.suffix ? ` ${e3.suffix}` : ""}
        </span>
      </div>
    `;
      var t2;
    }).join("")}</div>
      </div>
    `;
  }
  getFieldsConfig(e2) {
    if (this.config.popupFields) {
      const t2 = "function" == typeof this.config.popupFields ? this.config.popupFields(e2) : this.config.popupFields;
      return Array.isArray(t2) ? t2 : [];
    }
    return [{ label: "Province:", value: e2.provincia }, { label: "Municipality:", value: e2.municipio }, { label: "Polygon:", value: e2.poligono }, { label: "Parcel:", value: e2.parcela }, { label: "Enclosure:", value: e2.recinto }, { label: "Use:", value: e2.uso }, { label: "Surface:", value: e2.superficie, suffix: "ha" }];
  }
}
_c_instances = new WeakSet();
p_fn = function(e2, t2, i2) {
  const r2 = this.geometryManager.addMarker(t2, { title: `Parcela SIGPAC: ${e2.poligono}-${e2.parcela}` });
  r2.parcelaData = e2, this.geometryManager.bindPopup(r2, i2);
};
h_fn = function(e2, t2) {
  const i2 = this.popupPool.pop() || L.popup();
  return i2.setLatLng(e2).setContent(t2).openOn(this.map), i2.on("remove", () => {
    this.popupPool.push(i2);
  }), i2;
};
class l {
  static load(e2) {
    return new Promise((t2, i2) => {
      if (e2.checkLoaded && e2.checkLoaded()) return void t2();
      const r2 = document.createElement("script");
      r2.src = e2.url, e2.integrity && (r2.integrity = e2.integrity, r2.crossOrigin = "anonymous"), r2.onload = () => {
        setTimeout(() => {
          e2.checkLoaded && !e2.checkLoaded() ? i2(new Error(`Failed to load ${e2.url} - Check function returned false`)) : t2();
        }, 100);
      }, r2.onerror = (t3) => {
        i2(new Error(`Failed to load script: ${e2.url}`, { cause: t3 }));
      }, document.head.appendChild(r2);
    });
  }
  static async loadAll(e2) {
    for (const t2 of e2) try {
      await this.load(t2);
    } catch (e3) {
      throw console.error(`Error loading script: ${t2.url}`, e3), e3;
    }
  }
}
class h {
  constructor(e2, t2) {
    __privateAdd(this, _h_instances);
    this.map = e2, this.config = t2, this.layerStore = /* @__PURE__ */ new Map(), this.defaultIcon = L.icon({ iconUrl: this.config.markerIconUrl, iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34] }), this.wktParser = null;
  }
  addMarker(e2, t2 = {}) {
    const i2 = L.marker(e2, { icon: t2.icon || this.defaultIcon, ...t2 });
    return __privateMethod(this, _h_instances, g_fn).call(this, i2, "marker"), i2;
  }
  async addWkt(e2) {
    try {
      this.wktParser || (this.wktParser = await __privateMethod(this, _h_instances, d_fn).call(this));
      const t2 = this.wktParser.parse(e2), i2 = L.geoJSON(t2);
      return __privateMethod(this, _h_instances, g_fn).call(this, i2, "wkt"), i2;
    } catch (e3) {
      return console.error("WKT parse error:", e3), null;
    }
  }
  bindPopup(e2, t2) {
    e2 && t2 && e2.bindPopup(t2);
  }
  removeLayer(e2) {
    e2 && this.layerStore.has(e2) && (this.map.removeLayer(e2), this.layerStore.delete(e2));
  }
  clearLayers() {
    this.layerStore.forEach((e2, t2) => {
      this.map.removeLayer(t2);
    }), this.layerStore.clear();
  }
}
_h_instances = new WeakSet();
d_fn = async function() {
  try {
    if ("undefined" != typeof window && window.Terraformer || await l.loadAll([this.config.externalLibs.terraformer, this.config.externalLibs.terraformerWkt]), "undefined" == typeof window || !window.Terraformer) throw new Error("Failed to load WKT parser after script loading");
    this.wktParser = window.Terraformer.WKT;
  } catch (e2) {
    throw console.error("Error loading WKT parser:", e2), e2;
  }
};
g_fn = function(e2, t2) {
  this.layerStore.set(e2, { type: t2, addedAt: Date.now() }), e2.addTo(this.map);
};
class p {
  constructor(e2, t2, i2) {
    this.config = e2, this.mapContainer = t2, this.eventBus = i2;
  }
  emitFeatureSelected(e2, t2) {
    this.eventBus.emit("featureSelected", { data: e2, coordinates: t2 });
    const i2 = new CustomEvent("sigpac:featureSelected", { detail: { data: e2, coordinates: [t2.lat, t2.lng] }, bubbles: true });
    this.mapContainer.dispatchEvent(i2);
  }
  emitLivewireEvent(e2, t2) {
    this.config.livewire && window.livewire && window.livewire.emit(this.config.livewireEvent || "sigpacFeatureSelected", { data: e2, coordinates: [t2.lat, t2.lng] });
  }
}
class g {
  constructor(t2 = {}) {
    __privateAdd(this, _g_instances);
    this.userConfig = t2, this.eventBus = new e(), this.currentAbortController = null;
  }
  init(e2, t2 = {}) {
    if ("undefined" == typeof L) throw new Error("Leaflet not loaded");
    return __privateMethod(this, _g_instances, u_fn).call(this), __privateMethod(this, _g_instances, f_fn).call(this), __privateMethod(this, _g_instances, m_fn).call(this, e2, t2), __privateMethod(this, _g_instances, y_fn).call(this), __privateMethod(this, _g_instances, w_fn).call(this), this.logger.info("Leaflet map initialized"), this.map;
  }
  destroy() {
    this.currentAbortController && (this.currentAbortController.abort(), this.currentAbortController = null), this.eventBus.offAll(), this.map.off(), this.map.remove(), this.subsystems = null, this.logger.debug("MapManager destroyed");
  }
  async handleMapClick(e2) {
    this.logger.debug("Map click detected", e2.latlng), this.currentAbortController && this.currentAbortController.abort();
    const t2 = new AbortController();
    if (this.currentAbortController = t2, this.map.getZoom() < this.config.minZoomFeature) return void this.popupManager.showErrorPopup(e2.latlng, `Zoom in to level ${this.config.minZoomFeature}+ to view SIGPAC parcels`);
    const i2 = this.geometryManager.addMarker(e2.latlng, { title: "Cargando datos SIGPAC...", icon: this.config.markerLoadingIcon });
    "popup" === this.config.interactionMode && this.popupManager.showLoadingPopup(e2.latlng);
    try {
      const r2 = await this.sigpacService.fetchParcelaByCoordinates(e2.latlng, { signal: t2.signal });
      t2.signal.aborted || this.geometryManager.removeLayer(i2), r2 ? (this.popupManager.showParcelaInfo(r2, e2.latlng), this.eventManager.emitFeatureSelected(r2, e2.latlng), this.eventManager.emitLivewireEvent(r2, e2.latlng)) : this.popupManager.showErrorPopup(e2.latlng, "No SIGPAC parcels found at this location");
    } catch (t3) {
      if ("AbortError" === t3.name) return void this.logger.debug("Fetch aborted");
      this.logger.error("Error handling map click", t3), i2.setIcon(this.config.markerErrorIcon), i2.bindPopup(`<div class="sigpac-error">${t3.message || "Error fetching data"}</div>`), "popup" === this.config.interactionMode && this.popupManager.showErrorPopup(e2.latlng, "Error fetching parcel data");
    }
  }
}
_g_instances = new WeakSet();
u_fn = function() {
  this.configManager = new s(this.userConfig), this.config = this.configManager.getConfig();
};
f_fn = function() {
  this.logger = new i(this.config.debug);
};
m_fn = function(e2, t2) {
  const i2 = { ...this.config.defaultMapOptions, ...t2 };
  this.map = L.map(e2, { attributionControl: false }), L.control.attribution({ position: "bottomright" }).addTo(this.map), this.map.setView(i2.center, i2.zoom);
};
y_fn = function() {
  this.geometryManager = new h(this.map, this.config), this.layerManager = new n(this.config, this.map), this.popupManager = new c(this.map, this.config, this.geometryManager), this.eventManager = new p(this.config, this.map.getContainer(), this.eventBus), this.sigpacService = new a(this.config, this.logger), this.subsystems = { geometryManager: this.geometryManager, layerManager: this.layerManager, popupManager: this.popupManager, eventManager: this.eventManager, sigpacService: this.sigpacService }, this.layerManager.initBaseLayer(this.config.defaultMapOptions), this.layerManager.initSigpacLayer(), this.userConfig.hasOwnProperty("initialFeatures") || this.map.addLayer(this.layerManager.sigpacLayer), this.layerManager.setupLayerControl(), __privateMethod(this, _g_instances, b_fn).call(this);
};
w_fn = function() {
  false !== this.config.clickEnabled ? (this.map.on("click", __privateMethod(this, _g_instances, v_fn).call(this, this.handleMapClick.bind(this), 300)), this.eventBus.on("featureSelected", (e2) => {
    this.logger.info("Feature selected", e2);
  })) : this.logger.info("Map click disabled");
};
b_fn = function() {
  Array.isArray(this.config.initialFeatures) && this.config.initialFeatures.forEach((e2) => {
    let t2;
    "marker" === e2.type && e2.coordinates ? t2 = this.geometryManager.addMarker(e2.coordinates) : "wkt" === e2.type && e2.data && (t2 = this.geometryManager.addWkt(e2.data)), t2 && e2.popupContent && this.geometryManager.bindPopup(t2, e2.popupContent);
  });
};
v_fn = function(e2, t2) {
  let i2;
  return (...r2) => {
    clearTimeout(i2), i2 = setTimeout(() => e2.apply(this, r2), t2);
  };
};
if ("undefined" != typeof window) {
  const e2 = { MapManager: g, CoordinateCache: r, autoInit: function() {
    document.querySelectorAll("[data-sigpac-map]").forEach((e3) => {
      try {
        const t2 = JSON.parse(e3.dataset.config || "{}"), i2 = JSON.parse(e3.dataset.options || "{}");
        new g(t2).init(e3, i2);
      } catch (t2) {
        console.error("SIGPAC map initialization failed. Please check configuration format.", t2, e3);
      }
    });
  }, getManager: function(e3) {
    var _a;
    return (_a = e3.leafletSigpac) == null ? void 0 : _a.manager;
  } };
  window.LeafletSigpac = Object.assign(window.LeafletSigpac || {}, e2), document.addEventListener("DOMContentLoaded", () => {
    window.LeafletSigpac.autoInit && window.LeafletSigpac.autoInit();
  });
}
//# sourceMappingURL=leaflet-sigpac.es.min.js.map
